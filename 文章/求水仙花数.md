这是原始的题目的解法，要求N=4~7的情况下的水仙花数
```c
#include<stdio.h>
int istrue(int a, int N);
int i_pow(int x, int N);
int main()
{
	int N = 0, i;
	scanf("%d", &N);
	for (i = i_pow(10, N - 1); i < i_pow(10, N); i++)
	{
		if (istrue(i, N))
			printf("%d\n", i);
	}
	return 0;
}
int istrue(int a, int N)
{
	int p = 0, temp = a;
	while (temp > 0)
	{
		int b = temp % 10;
		p = p + i_pow(b, N);
		temp = temp / 10;
	}
	return (p == a);
}
int i_pow(int a, int N)
{
	int i = 1, p = 1;
	for (i = 0; i < N; i++)
	{
		p = p * a;
	}
	return p;
}

```
这是加上long long的程序，可计算更多位的水仙花数。
```c
//这是一个寻找水仙花数的程序

#include<stdio.h>
int istrue(long long a, int N);
long long fast_pow(long long base, unsigned int exp);
int main()
{
    int N = 0;

    long long i;

    scanf("%d", &N);

    for (i = fast_pow(10, N - 1); i < fast_pow(10, N); i++)
    {
        if (istrue(i, N))
            printf("%lld\n", i);
    }
    printf("End of Output\n");
    return 0;
}

int istrue(long long a, int N)
{
    long long p = 0;
    long long temp = a;
    while (temp > 0)
    {
        int b = temp % 10;
        p = p + fast_pow(b, N);
        temp = temp / 10;
    }  
    return (p == a);
}
long long fast_pow(long long base, unsigned int exp)
{
    long long result = 1;
    while (exp > 0)
    {
        if (exp & 1)
        {          
            result *= base;
        }
        base *= base;            
        exp=exp/2;          
    }
    return result;//快速幂算法
}
```
这个程序速度实在是太慢了，算个10位的水仙花数要跑半个小时，以下是对其进行一些微调的版本。
```c
//这是一个优化过的找水仙花数的程序，对算法进行微调
#include <stdio.h>
int istrue(long long a, int N, long long power_table[]);
long long simple_pow(int base, int exp);
int main()
{
    int N;
    scanf("%d", &N);
    // 预计算 0~9 的 N 次方
    long long power_table[10];
    for (int d = 0; d <= 9; d++)
    {
        power_table[d] = simple_pow(d, N);
    }
    // 只计算一次上下界
    long long start = 1;
    for (int i = 1; i < N; i++) start *= 10; // 10^(N-1)
    long long end = start * 10;                // 10^N
    // 遍历所有 N 位数
    for (long long i = start; i < end; i++)
    {
        if (istrue(i, N, power_table))
        {
            printf("%lld\n", i);
        }
    }
    printf("End of Output\n");
    return 0;
}
// 简单幂函数，适用于小底数和小指数
long long simple_pow(int base, int exp)
{
    if (exp == 0) return 1;
    long long result = 1;
    for (int i = 0; i < exp; i++)
    {
        result *= base;
    }
    return result;
} 
int istrue(long long a, int N, long long power_table[])
{
    long long p = 0;
    long long temp = a;
    while (temp > 0)
    {
        int b = temp % 10;
        p += power_table[b]; // 直接查表，O(1)
        temp /= 10;
    }
    return (p == a);
}
```
以上程序主要修改在以下几点：
	1.只计算一次上下界
	2.使用简单幂函数，适用于小底数和小指数
	3.预计算 0~9 的 N 次方，直接查表
然而这个程序还是很慢
询问ai得到了一种新算法：先计算出N个数字的幂和的集合，再选取范围合适的数字，这样我们就找到了水仙花数，算法的复杂度大大降低。
```c
//这是一个大幅优化的版本，利用了数字组合的性质，避免了大量不必要的计算。
#include <stdio.h>
// 全局变量，用于递归中共享
int N;
long long power_table[10];
int digit_counts[10]; // 记录当前组合中每个数字(0-9)出现的次数
long long fast_pow(int base, int exp) ;
void dfs(int current_digit, int digits_left, long long current_sum);
void check(long long sum);
int main()
{
    // 读取输入 N
    scanf("%d", &N);
        // 1. 预计算 0-9 的 N 次幂
    for (int i = 0; i <= 9; i++)
    {
            power_table[i] = fast_pow(i, N);
    }
        // 2. 初始化计数器
    for (int i = 0; i <= 9; i++) digit_counts[i] = 0;
        // 3. 开始 DFS
        // 从数字 9 开始尝试，初始剩余 N 个空位，初始和为 0
    dfs(9, N, 0);          
    printf("End of Output\n");
    return 0;  
}
// 快速幂计算 (仅用于预计算)
long long fast_pow(int base, int exp)
{
    long long res = 1;
    for (int i = 0; i < exp; i++) res *= base;
    return res;
}  
// 检查幂和是否符合条件
void check(long long sum)
{    
// 1. 计算 sum 的总位数 和 每个数字出现的次数
    long long temp = sum;
    int sum_counts[10] = {0};
    int total_digits = 0;
    while (temp > 0)
    {
        sum_counts[temp % 10]++;
        temp /= 10;
        total_digits++;
    }
    // 2. 剪枝：如果位数不对，直接返回
    if (total_digits != N) return;
    // 3. 核心验证：比较 sum 的数字统计 与 当前组合的数字统计 是否一致
    for (int i = 0; i <= 9; i++)
    {
        if (sum_counts[i] != digit_counts[i])
        {
            return; // 不匹配
        }
    }
    // 4. 通过验证，输出结果
    printf("%lld\n", sum);
}
/**
 * DFS 搜索所有数字组合
 * @param current_digit 当前正在考虑放入组合的数字 (9 -> 0)
 * @param digits_left   组合中还剩多少个空位
 * @param current_sum   当前组合的幂和
 */
void dfs(int current_digit, int digits_left, long long current_sum)
{
    // 边界条件：如果所有位置都填满了
    if (digits_left == 0)
    {
        check(current_sum);
        return;
    }
    // 边界条件：如果数字已经尝试到 -1 了 (不应该发生，但作为保险)
    if (current_digit < 0) return;
    // 剪枝：如果当前和已经超过 N 位数的最大值(10^N - 1)，可以提前停止（可选，视情况而定）
    // 这里简化处理，不做复杂剪枝，直接遍历完组合。
    if (current_digit == 0)
    {
        // 如果只剩下 0 了，剩下的空位全部填 0
        digit_counts[0] += digits_left;
        // 0 的幂和是 0，所以 current_sum 不变
        check(current_sum);
        digit_counts[0] -= digits_left; // 回溯
        return;
    }
    // 核心递归：尝试当前数字 current_digit 出现 i 次 (i 从 0 到 digits_left)
    for (int i = 0; i <= digits_left; i++)
 {
        digit_counts[current_digit] = i; // 记录当前数字选了 i 个
        // 继续递归下一个更小的数字，剩余空位减少 i，幂和增加 i * power_table[current_digit]
        dfs(current_digit - 1, digits_left - i, current_sum + i * power_table[current_digit]);
    }
    // 回溯：恢复状态 (虽然上面的循环每次都覆盖 digit_counts[current_digit]，但好习惯是恢复)
    digit_counts[current_digit] = 0;
}
```
